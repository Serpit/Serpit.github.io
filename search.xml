<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android杂七杂八]]></title>
    <url>%2F2019%2F02%2F22%2FAndroid%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%2F</url>
    <content type="text"><![CDATA[Android杂七杂八Activiy1、生命周期onCreate() -&gt; onStart() -&gt; onResume() -&gt; onPause() -&gt; onStop() -&gt; onDestroy() 横竖屏切换生命周期会重来此外，Activity中的变量会为重新初始化，此时利用Bundle可以很好的解决问题，每次onCreate()调用的时候都会带来一个Bundle，这个Bundle就会携带一些数据，而这些数据的来源是来自于Activity中的onSaveInstanceState()中所保存的，若没有调用该方法，默认为null; activity启动模式：standard、singleTop、singleTask、singleInstance Standard:每次激活Activity时，都创建Activity实例 SingleTop:如果某个Activity自己激活自己，即任务栈栈顶就是该Activity，则不需要创建，否则其余情况都需要创建该实例，新闻推送页 SingleTask:如果要激活的Acvtivity在任务栈中存在该实例，则不需要创建，只需要把此Activity放入栈顶，并把该Activity上面的Activity都POP，，首页 SingleInstance:如果应用1的任务栈中创建了该实例，如果应用2也要激活该实例，则不需要创建，两应用共享该实例 back：finish-&gt;onPause-&gt;onStop-&gt;onDestory。也就是说点击了back后，再次进入该activity需要重新onCreate home：onPause-&gt;onStop。此时Activity实例并没有销毁，所以再次进入时走onRestart-&gt;onStart-&gt;onResume 横竖屏切换：onPause –&gt;onSaveInstanceState –&gt;onStop –&gt;onDestroy –&gt;onCreate–&gt;onStart –&gt;onRestoreInstanceState–&gt;onResume –&gt;onPause –&gt;onStop –&gt;onDestroy TaskAffinity affinity指的是activity与task的吸附关系，也就是activity属于哪个task。每个activity都有android:taskAffinity属性，若不声明则使用的是application的taskAffinity的值，若application也没有声明该属性，则使用应用包名来作为该属性的值。该值可以是任何字符串，但必须包含一个 . ，否则会报错 应用 根据affinity重新为activity选择宿主task，需要与allowTaskReparenting属性配合使用 allowTaskReparenting用来标记Activity能否从启动的Task移动到taskAffinity指定的Task，当把Activity的allowTaskReparenting属性设置成true时，Activity就拥有了一个转移所在Task的能力。具体点来说，就是一个Activity现在是处于某个Task当中的，但是它与另外一个Task具有相同的affinity值，那么当另外这个任务切换到前台的时候，该Activity就可以转移到现在的这个任务当中。allowTaskReparenting默认是继承至application中的allowTaskReparenting=false，如果为true，则表示可以更换；false表示不可以。 启动一个actvity过程中，intent使用FLAG_ACTIVITY_NEW_TASK标记，根据cffinity查找或创建一个新的具有对应affinity的task 当调用startActivity()方法来启动一个Activity时，默认是将它放入到当前的任务当中。但是，如果在Intent中加入了FLAG_ACTIVITY_NEW_TASK flag的话，情况就会变的复杂起来。首先，系统会去检查这个Activity的affinity是否与当前Task的affinity相同。如果相同的话就会把它放入到当前Task当中，如果不同则会先去检查是否已经有一个名字与该Activity的affinity相同的Task,如果有，这个Task将被调到前台，同时这个Activity将显示在这个Task的顶端；如果没有的话，系统将会尝试为这个Activity创建一个新的Task。需要注意的是，如果一个Activity在manifest文件中声明的启动模式是”singleTask”，那么他被启动的时候，行为模式会和前面提到的指定FLAG_ACTIVITY_NEW_TASK一样。 Intent匹配规则action匹配规则intent中的action能够过和过滤规则中的任何一个action相同即为匹配成功。若intent没有指定action，那么匹配失败 category匹配规则intent中的所有的category都必须和过滤规则中的category相同。若intent中没有category，则intent仍然可以匹配成功 data匹配规则如果过滤规则中定义了data，那么intent必须也要定义匹配的data Context的种类application、activity、service、brocast、contentProvider 除了activity，其他context启动activity会另开任务栈,其他context使用layoutInflate会使用系统默认主题，自定义的主题可能不会被使用，其他context不可以show a dialog brocastReceiver的context不可以bindService，不可以register brocastReceiver 2.Fragment生命周期Fragment的生命周期和Activity有点类似，按顺序来有这几种：Created-&gt;Started-&gt;Resumed-&gt;Paused-&gt;Stopped-&gt;Destroyed 其中Created包括：onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onAcivity() Started包括：onStart() Resumeed包括: onResume() Paused包括: onPause() Stopped包括：onStop() Destroyed包括：onDestroyView() -&gt; onDestroy() -&gt; onDetach() 3.View的工作过程onMeasure -&gt; onLayout -&gt; onDraw 4.AIDLAIDL是一种帮助开发者实现Binder的一种工具 利用AIDL来创建Binder总共需要三个文件 基本简单java类 (如Book.java)，并实现Parcelable接口进行序列化 声明该类的.aidl文件，如Book.aidl， 操作该类的aidl文件，在里面声明操作这个类的行为(如 addBook , getBookList…)，此文件里的声明类似于java里的接口 Binder实现IPCService12345678910111213141516//IBookManager.Stub是一个Binder，利用这个AIDL生成的Binder就可以轻松实现对数据的操作，并且能响应客户端的请求private IBookManager.Stub mBookManager = new IBookManager.Stub() &#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBooks; &#125; @Override public void addBook(Book book) throws RemoteException &#123; mBooks.add(book); &#125; &#125;; //Service中利用bind方法可以和客户端绑定，并将这个Binder返回，使得客户端和Service操作同一个Binder Client123//Activity作为客户端//Activity客户端需要构建一个ServiceConnection和Service建立连接，并利用这个Connection来得到Binder//利用这个Binder就可以操作数据，使得操作远程的数据像本地的数据一样方便 5、Service生命周期1、普通启动startService onCreate -&gt; onStartCommand -&gt; onDestroy 2、绑定启动bindService onCreate -&gt; onBind -&gt; onUnbind -&gt; onDestory 多次调用startService只会重复调用onStartCommand方法，不会多次调用onCreate，如果一个service又start又bind，那么它不能通过stopService方法结束，而是先要通过unBindService才能结束 6、LruChache1、使用方法12345678int maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024); int cacheSize = maxMemory/8; mMemoryCache = new LruCache&lt;String,Bitmap&gt;(cacheSize)&#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes()*value.getHeight()/1024; &#125; &#125;; ①设置LruCache缓存的大小，一般为当前进程可用容量的1/8。②重写sizeOf方法，计算出要缓存的每张图片的大小。 注意：缓存的总容量和每个缓存对象的大小所用单位要一致。 内部原理 思想：维护一个列表，对象列表的排列方式时按照访问顺序实现的，即一直没访问的对象，将放在队尾，即将被淘汰。而最近访问的放在队头，最后被淘汰。 队列由LinkedHashMap来维护 put过程在map里添加元素，调用trimToSize()判断缓存是否满了，如果满了，就用linkedHashMap的迭代器删除队尾元素，即近期最少访问的元素 get过程调用linkedhashmap的get方法获得对应的元素，并更新该元素到队头 内存抖动 内存抖动是由于短时间内有大量对象进出Young Generiation区导致的，它伴随着频繁的GC 避免： 尽量避免在循环体内创建对象，应该把对象创建移到循环体外。 注意自定义View的onDraw()方法会被频繁调用，所以在这里面不应该频繁的创建对象。 当需要大量使用Bitmap的时候，试着把它们缓存在数组中实现复用。 对于能够复用的对象，同理可以使用对象池将它们缓存起来。 Android类加载器由于android中执行的是dex文件，而并非是class文件，因此android不能使用jvm的类加载器去加载class文件。安卓中的类加载器分为三种 BootClassLoader，该类是在android在启动的时候来预加载常用类，与jvm中的BootStrap classloader 不同的是，它不是由C/C++实现的，而是由java实现的，它是ClassLoader的内部类PathClassLoader用来操作本地文件系统中的文件和目录的集合。并不会加载来源于网络中的类。Android采用这个类加载器一般是用于加载系统类和它自己的应用类。这个应用类放置在data/data/包名下。 PathClassLoader，可以加载已经安装的apk，也就是/data/app/package下的apk文件，也可以加载/vendor/lib/,/system/lib下的nativeLibrary DexClassLoader dalvik/system.DexClassLoader,可以加载一个未安装的apk文件 SQLite使用优化 SQLite会默认（不手动开启的情况下）为所有插入和更新创建事务，即如果有一千条记录插入，会执行一千次【创建事务-&gt; 插入 -&gt; 结束事务】的操作，因此需要手动去开启事务来减少插入或更新时事务开启带来的性能损耗，方式如下： 12345678SQLiteDataBase db = mSQLiteHelper.getWriteableDatabase();db.beginTransatction();for(int i = 0;i&lt;100;i++)&#123; db.insert(xxxx);&#125;db.setTransactionSuccessful(true);//设置事务执行成功db.endTransaction(); 在构建sql语句时，使用StringBuilder和StringBuffer 在查询的时候，尽可能查询时查出具体所要的值，而不要查出一列或一行，再进而进行查询 cursor使用后要及时关闭 建立以及使用索引 尽量将sql的操作放在子线程中，因为sql的操作属于本地IO操作]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经答案]]></title>
    <url>%2F2019%2F02%2F22%2F%E9%9D%A2%E7%BB%8F%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Android 的消息机制 Android的消息机制主要是指Handler运行的机制。Handler的运行需要底层的MessageQueue和Looper的支撑。Handler的主要作用是将一个任务切换到某个指定的线程中去执行。 Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，若当前线程没有Looper则报错。当Handler创建完毕后，内部的Looper以及MessageQueue就可以和Handler一起协同工作了 通过Handler的post方法将一个Runnable投递到Handler，也可以通过Handler的send方法发送一个消息 send方法调用时，会调用MessageQueue的enqueueMessage方法将这个消息放入消息队列中 当Looper发现有消息到来时，就会处理这个消息，最后消息中的Runnable或者Handler中的handleMessage方法会被调用。 Looper是运行在创建Handler的线程中的 ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在线程中可以获得存储的数据，对于其他线程来说则无法获取到数据。对于Handler来说，它需要获取当前线程的Looper，就可以采用ThreadLocal。 消息队列在Android中指的是MessageQueue，它主要包含读取和插入两种操作，读取本身带有删除的操作。它实际上是用单链表的数据结构来维护消息列表，这是因为单链表在插入和删除上比较有优势 Looper扮演的是消息循环的角色，他会从MessageQueue队列中不断地查看是否有新消息，如果有就处理，没有就阻塞 Android View的测量流程测量需要从MeasureSpec说起，它参与了View的测量过程，它很大程度地决定了一个View的尺寸规格，同时父容器还会影响View的MeasureSpec的创建过程。在测量的过程中，系统会将View的LayoutParams根据父容器所施加的规则转换成应对的MeasureSpec，然后根据这个MeasureSpec来测量出View的宽高。 MeasureSpec是一个32位的int值，高2位代表SpecMode，低30位代表SpecSize（某模式下的测量大小）。可以通过给View设置LayoutParams，在View测量的时候，系统会将LayoutParams在父容器的约束下转换成对应MeasureSpec，再根据这个MeasureSpec来确定View测量后的宽高。 转换过程：MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定的。 Match_parent、精确值是精确模式，Wrap_content是最大模式 当宽/高为精确值时，不管父容器的MeasureSpec是什么，View的MeasureSpec都是精确模式，并且遵循LayoutParmas中的大小。 当宽/高为match_parent时，如果父容器的模式为精确模式，那么View也是精确模式，并且其大小是父容器的剩余空间；如果父容器是最大模式，那么View也是最大模式并且其大小不会超过父容器的剩余空间。 当宽/高为wrap_content时，不管父容器的模式时精准还是最大化，View的模式总是最大化且大小不能超过父容器的剩余空间 measure的测量过程是通过measure方法（finally，子类不能继承）来完成，在这个方法里面会调用onMeasure。而onMeasure里只有一个设置宽高的方法。 宽的来源是先判断测量模式，如果是Unspecified，则使用android:minWidth属性里的值（如没设置默认为0），若不是Unspecified，则使用MeasureSpec里的大小。高的做法亦是如此 Android View的layou过程Layout的作用是ViewGroup用来确定子元素的位置。当ViewGroup的位置被确定以后，它会在onLayout中遍历所有的子元素并调用其layout方法，layout方法里面又会调用（ViewGroup）onLayout方法。 View的layout方法大致流程如下：首先会通过setFrame方法来设定View的四个顶点位置，view的四个顶点一旦确定，那么View在父容器中的位置也就确定。接着会调用onLayout方法，这个方法的用途是父容器确定子元素的位置（通常在onLayout里会调用子View的layout方法，这样就可以让父容器知道子View的位置了） Android View 绘制流程 DecoreView : DecoreView作为顶级View，一般情况下它内部都会包含一个LinearLayout，这个LinearLayout分为上下两个部分，上面是标题栏，下面是内容栏。 ViewRoot：ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带。在ActivityThread中，当Activity对象被创建完毕以后，会将DecoreView添加到Window中，同时创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联 view的过程遵循几步： 绘制背景（background.draw(canvas)） 绘制自己（onDraw） 绘制children（dispatchDraw） 绘制装饰（onDrawScrollBars） View的绘制流程是由ViewRoot开始的，经过measure、layout、和draw三个过程才能将一个View绘制出来 如果控件内部卡顿你如何去解决并优化？ 扁平化处理，防止过度绘制OverDraw 尽量减少layout的层级嵌套 图片选择：界面最好选用png，因为32位的png颜色过度平滑且支持透明（因为jpg的质量下降了）。对于颜色繁杂的，照面墙纸之类的图片（应用的启动画面），尽量用jpg，因为体积小 清理不必要的背景，如被覆盖的可以将其背景去掉 当背景无法避免的时候，尽量使用Color.Transparent（透明色不会渲染） 可以通过自定义Theme来避免一些background的设置 优化自定义View的计算，优化UI线程的工作量，简化运算 避免在自定义View的时候频繁的GC，因为GC会导致所有的线程会停下的 Android dp、px、dip相关概念 dp：即dip，一个基于density的抽象单位，android中定义了四种像素密度：低（120dip）、中（160dip）、高（240dip）和超高（320dip），它们对应的dp到px的系数分别为0.75、1、1.5、2,如80dp如果在240dip上显示就为80*1.5=120px px：像素，1px代表屏幕上的一个物理的像素点 sp：字体大小单位，字体也有小、正常、大、超大等，因此和dp类似也有相应的换算成dp的规则 ViewStub加载原理ViewStub只能被加载一次，重复加载会导致异常，这是因为ViewStub只要被加载过一次，就会把自身移除，把自身所包含的内容全部交给父布局。ViewStub使用的是惰性加载原理，即将其放在布局文件中，如果没有进行加载那就为空，不像其他控件一样只要布局文件中声明就会存在。 从输入URL到页面加载发生了什么 DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 一次完整的HTTP请求过程 域名解析 发起TCP3次握手 建立TCP连接以后发起HTTP请求 服务器响应HTTP请求 Activity的四种启动模式是什么？ SingleTop：如果此Activity在栈顶，就会复用该activity，若该activity不在栈顶，则重新创建实例并添加到栈顶 SingleInstance：会为一个Acitivity独立创建一个任务栈 SingleTask：若一个Activity位于栈内，都不会创建该Activity，若在栈顶，则直接返回本身，若不在栈顶则将它上面的activity出栈 Stander：默认的启动模式，每次都会重新创建一个实例 IPC有哪几种？为什么要使用BinderIPC有以下几种： Linux的管道和消息队列 共享内存 socket Android的IPC: Message Bundle Messenger AIDL Socket ContentProvider Binder有一个很突出的优点就是–复杂数据类型可以复用内存 socket是一个通用接口，导致传输效率低开销大，主要用在跨网络的进程通信和本机进程的低速传输 管道和消息机制，因为存储采用转发方式，所以至少需要拷贝2次数据，效率低 共享内存，传输时没有拷贝数据，但其控制方式及其复杂 另外，Binder的安全性也较高 Shareprefence进程通信shareprefence进程通信需要设置MODE_WORLD_READABLE模式，另外在读取数据的一端需要用写数据端的包名构造context1context = createPackageContext(&quot;com.example.shareprefencesharea&quot;, Context.CONTEXT_IGNORE_SECURITY); 如何实现两个线程打印”12121212…””保证顺序 使用synchronized加wait()和notifyAll()的方法 1234567891011121314151617181920212223242526272829303132333435363738394041public class Main &#123; public static void main(String[] args) &#123; Object object = new Object(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; synchronized (object) &#123; System.out.println(1); object.notifyAll(); try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; synchronized (object) &#123; System.out.println(2); object.notifyAll(); try &#123; object.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;).start();; &#125;&#125; 注意wait、notify方法一定要与锁（即放到synchronized代码块中）使用 保证service不被杀死 onStartCommand返回START_STICKY service+broadcast的方式，当service调用onDestroy的时候发送广播，当收到广播的时候重新启动该service 在application标签中加上android:persistent=“true” 监听系统的广播判断service状态并判断是否重启，比如手机重启，界面唤醒，应用状态改变等 如何优化下载？1、采用断点下载 原理：使用HTTP/1.1的Range请求头Range: bytes=0-499 // bytes (unit first byte pos) - [last byte pos]/[entity legth] 思路：获取下载文件的总大小，获取本地文件，不存在就下载，存在获取文件大小。如果本地文件大小与网络上的大小一致，下载完成。如果本地大小&lt;网络上的大小，跳过已下载的字节数开始下载 ANR造成的原因？在主线程里面做了太多阻塞耗时操作 ANR分析？定位？ANR产生时会在/data/anr/下产生traces.txt文件,分析该文件即可。 onSaveInstanceState()方法？何时会调用？当activity有可能被系统回收的情况下，而且是在onStop()之前。注意是有可能，如果是已经确定会被销毁，比如用户按下了返回键，或者调用了finish()方法销毁activity，则onSaveInstanceState不会被调用。或者也可以说，此方法只有在activity被异常终止的情况下会被调用。 总结下，onSaveInstanceState(Bundle outState)会在以下情况被调用： 当用户按下HOME键时。 从最近应用中选择运行其他的程序时。 按下电源按键（关闭屏幕显示）时。 从当前activity启动一个新的activity时。 屏幕方向切换时(无论竖屏切横屏还是横屏切竖屏都会调用)。 在前4种情况下，当前activity的生命周期为：onPause -&gt; onSaveInstanceState -&gt; onStop。 第5种情况屏幕方向切换时，activity生命周期如下：onPause -&gt; onSaveInstanceState -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume Parcelable与Serializable区别为什么要序列化？ 永久性的保存对象，保存对象的字节序列到本地文件中 通过序列化的对象在网络中传递对象 通过序列化在进程间传递对象 选择序列化方法的原则 在使用内存的时候，Parcelable比Serializable性能高 Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。 Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点，但此时还是建议使用Serializable 。 为什么Parcelable性能比Serializable好因为Serializable在序列化的时候采用了大量的反射，会产生大量的临时变量，从而产生过高的负载 onNewIntent()调用时机Activity第一启动的时候执行onCreate()—-&gt;onStart()—-&gt;onResume()等后续生命周期函数，也就时说第一次启动Activity并不会执行到onNewIntent(). 而后面如果再有想启动Activity的时候，那就是执行onNewIntent()—-&gt;onResart()——&gt;onStart()—–&gt;onResume().如果android系统由于内存不足把已存在Activity释放掉了，那么再次调用的时候会重新启动Activity即执行onCreate()—-&gt;onStart()—-&gt;onResume()等。 主线程与子线程的五种通信方式 Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable, long) Handler AsyncTask 抽象类和接口的区别 一个类可以实现多个接口，而一个类只能继承一个类 抽象类可以有具体实现的方法，而接口只能有抽象方法 抽象类可以声明和使用字段，接口则不能，但接口可以创建静态的final常量 接口的方法都是public的，抽象类的方法可以是public,protected,private或者默认的package 抽象类可以定义构造方法，接口却不可以 java线程之间通信方式 共享变量 a、synchronized、notify、wait b、lock和condition c、vlotile d、AtomicInteger 生产者消费者 LinkedBlockingQueue，生产者消费者模型 invalidate、postInvalidate、requetLayout方法的区别 requestLayout是要让view重新走measure，layout，draw这三个流程的 postInvalidate和invalidate只需要让view重新走绘制流程，那它两者的区别是postXXX在子线程使用，而invalidate在主线程使用 Android布局性能LinearLayout &gt; FrameLayout &gt; RelativeLayout Error与ExceptionError类和Exception类都是继承Throwable类 Error是系统中的错误，编译时出现，通过修改程序才能修正。一般出现在系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出。若出现仅靠程序本身无法恢复和预防，只能让程序终止 Exception表示程序可以处理的异常，可以捕获且修复，若发生要尽可能处理异常，使程序恢复运行，而不应该随意终止异常 Exception分两类 CheckException(编译异常，需要用try-catch显式捕获，对于可恢复的异常使用CheckException) UnCheckException(运行时异常，不需要捕获，对于程序错误的异常使用RuntumeException),常见的NullpointerException、IndexOutOfBoundsException 内存泄露场景和优化场景 静态变量导致的内存泄漏 activity里引用了一个静态context并将自己赋值给context，会导致activity无法回收 单例模式导致的内存泄露 单例模式的生命周期和应用的生命周期一样长，所以如果构造单例时有上下文的传入需要注意使用application的context 属性动画导致的内存泄漏 如果activity中播放无限循环的动画，且没有在onDestory中停止动画，那么动画会一直播放下去，会导致一直持有view，而view又持有activity，最终导致activity无法回收 内部类导致内存泄露 由于非静态内部类拥有外部类的持有外部类的引用，且生命周期比外部类较长，就导致内存泄漏，且还可能发生空指针的异常。常见：是new一个Thread和Handler,解决的办法是使用线程池或者在构建handler时使用弱引用的方法传递上下文 检测内存泄漏1、Android Lint Android Studio 内部提供的一个检测插件，会在编译完成后提供一些代码提示 2、leakcanaryleakcanary首先需要添加gradle的依赖，并在application中加入注册代码LeakCanary.install(),如果使用RefWatcher来进行监控 代码如下 1234567891011121314151617181920212223//改写Application 并提供静态方法返回ReWatcherpublic class LeakApplication extends Application &#123; private RefWatcher refWatcher; @Override public void onCreate() &#123; super.onCreate(); refWatcher= setupLeakCanary(); &#125; private RefWatcher setupLeakCanary() &#123; if (LeakCanary.isInAnalyzerProcess(this)) &#123; return RefWatcher.DISABLED; &#125; return LeakCanary.install(this); &#125; public static RefWatcher getRefWatcher(Context context) &#123; LeakApplication leakApplication = (LeakApplication) context.getApplicationContext(); return leakApplication.refWatcher; &#125;&#125;//在需要检测的地方写上 refWatcher.watch(this); 如何取消发送handler消息handler.removeMessage() MVC、MVP、MVVM MVC View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 MVP 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 MVVM 和MVP差不多，View的变动，自动反映在 ViewModelTCP如何保证可靠性传输确认机制、重传机制、滑动窗口 tcp发出一个段后，它启动一个定时器，等待目的端确认收到报文段，如不能收到确认，将重发这个报文。 流量控制，连接的每一方都有固定大小的缓冲空间，接收端指允许另一端发送接收端缓冲区所能接纳的数据。 UDP如何实现可靠性传输发送端：包的分片，包确认，包的重发接收端：包的调序、包的序号确认 开源程序利用UDP实现了可靠的数据传输，分别为RUDP、RTP、UDT HTTPS建立链接过程 客户端发起HTTPS请求 这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。 服务端的配置 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 传送加密信息 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务段解密信息 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息这部分信息是服务段用私钥加密后的信息，可以在客户端被还原 客户端解密信息客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。 TCP为什么最后还要保持TIME_WAIT2msl Client不能保证最后的ACK能到达Server,所以还应该观望一段时间，护送一段时间。如果最后的ACK丢失，那么Server显然收不到，于是Server发起了重传FIN的操作，此时如果Client处于CLOSED状态，就无法重发ACK了。所以Client要等待一个2MSL的时间，这段时间就是TIME_WAIT。因而，要实现TCP全双工连接的正常终止，必须处理终止过程中四个分节任何一个分节的丢失情况，主动关闭连接的Server端必须维持TIME_WAIT状态 。 允许老的重复分节在网络中消逝TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个迟到的迷途分节到达时可能会引起问题。在关闭“前一个连接”之后，马上又重新建立起一个相同的IP和端口之间的“新连接”，“前一个连接”的迷途重复分组在“前一个连接”终止后到达，而被“新连接”收到了。为了避免这个情况，TCP协议不允许处于TIME_WAIT状态的连接启动一个新的可用连接，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个新TCP连接的时候，来自旧连接重复分组已经在网络中消逝。 常见状态码 200 请求成功 201 请求成功且服务器建立了新的资源，且其URI已经随Location头信息返回 202 服务器已接受请求，但未处理 301 被请求的资源已永久移动到新位置 302 请求的资源临时从不同的URI响应请求 401 请求要求身份验证 403 服务器拒绝执行请求 404 请求失败，资源未找到 408 请求超时，服务端等待客户端时间过长 500 服务器处理失败，无法完成请求 503 服务器无法响应可能在维护或已经超载 504 网关超时 505 不支持的HTTP版本 Glide优缺点Glide能加载gif剪切、图形变化、占位图或错误图片 glide的库较大 Glide的缓存机制内存缓存使用key标记一个图片，构成key的参数主要有url,width,height等信息 分两种情况 使用中的图片使用弱引用缓存，并带有acquire()方法让变量++，和release()方法让变量– 没有使用的图片使用Lrucache缓存 硬盘缓存缓存算法是DiskLruCache 读取缓存需要区分DiskCacheStrategy.RESULT和DiskCacheStrategy.SOURCE两种策略，一种是处理过的，另一种是原图片 写入缓存是使用DiskLruCache的put方法写入硬盘缓存 RXjava 优点 支持错误处理 支持背压的操作 有线程调度功能 多种操作符方便处理数据 Retrofit对Okhttp进行封装，使用了动态代理的设置模式，对OKHTTP的Call进行创建，让网络请求像调用方法一样简单 常用的配置有： 超时时间，重连开关 日志打印的拦截器 缓存拦截器，设置缓存目录、缓存大小等 json转换器设置 如何获得多个样式的列表（ListView实现）通过判断对应position的类型，返回相应类型的view]]></content>
      <tags>
        <tag>Android</tag>
        <tag>JAVA</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程学习笔记]]></title>
    <url>%2F2019%2F02%2F22%2FJava%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1、线程的状态New:新创建的状态，还没调用start方法 Runnable:可运行状态，调用start之后，就处于该状态，这时候它可能在运行可能没有运行，那需要取决于系统是否给它提供运行时间 Blocked:阻塞状态，暂时不活动 Waiting:等待状态，暂时不活动且不运行任何代码，消耗最少的资源，知道线程调度器重新激活它 Timed Waiting:超时等待状态，与等待状态不同的是，它可以在指定的时间自行返回的 Terminated:终止状态，当前线程已经执行完毕。导致终止的两种情况，第一是，run方法执行完毕正常退出，第二种是因为没有捕捉的异常而终止了run方法，导致线程终止 2、创建线程的三种方法1、继承Thread类，重写里面的run方法12345678910public class TestThread extends Thread&#123; public void run()&#123; //耗时逻辑 &#125; public static void main(String[] args)&#123; Thread mThread = new TestThread(); mThread.start(); &#125;&#125; 2、实现Runnable接口，并实现该接口的run方法123456789101112public class TestRunnable implements Runnable&#123; public void run()&#123; //耗时逻辑 &#125; &#125;public calss Test&#123; public static void main(String[] args)&#123; new Thread(new TestRunnable()).start(); &#125;&#125; 3、实现Callable接口，重写call()方法12345678910111213141516171819public static void main(String[] args) &#123; MyTestCllable callable = new MyTestCllable(); ExecutorService mExecutorService = Executors.newSingleThreadExecutor(); Future mFuture = mExecutorService.submit(callable); try &#123; System.out.println(mFuture.get()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; static class MyTestCllable implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; return &quot;hello world&quot;; &#125; &#125; 执行结果： Callable属于Executor框架里面的功能类，call方法支持返回一个值，这个值的类型由实现接口时所带的泛型提供。运行Callable可以拿到一个Future的对象，他表示异步计算的结果，提供检查计算是否完成的方法，如下图所示。因为线程属于异步计算模型，所以无法从别的线程中得到函数的返回值，在这种情况下就可以使用Future来监视目标线程调用call()方法的情况。但是又有一个问题，调用future的get()方法获取结果会导致线程阻塞,直到call方法返回结果。 总结，这三种方法通常用第二种，原因是，一个类在其需要加强或者修改时候才会被继承，所以没有重写Thread的必要3、同步1、重入锁与条件对象1234567 Lock mLock = new ReentrantLock();mLock.lock();try &#123; //耗时操作&#125;finally &#123; mLock.unlock();&#125; 重入锁，用Lock锁住代码块(mLock.lock())进行玩耗时操作以后就调用unlock()进行解锁。但是，假想一下，倘若在耗时操里面有一个需要等待特别长时间的逻辑，这样就很容易出现死锁的问题。这是因为一旦加入了锁，就意味着外面的资源无法执行代码块里的逻辑。这时候就引入了条件对象==Condition==12//得到条件对象Condition condition = lock.newCondition(); 12345678//用法mLock.lock();try &#123; //阻塞当前线程并放弃锁 condition.await(); &#125;finally &#123; mLock.unlock(); &#125; 一旦调用了condition的await()方法，当前线程就会阻塞，一直到另外的线程调用condition的singalAll()方法，才能将阻塞状态解除。 2、synchronized当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码 如果一个方法用synchronized声明，那么对象的锁就会保护整个方法。123456789101112131415public synchronized void method()&#123; //something&#125;//上面代码等同于Lock mLock = new ReetranLock();public void method()&#123; mLock.lock(); try&#123; //something &#125;finally&#123; mLock.unlock(); &#125;&#125;` 3、线程池实现线程池的核心类：ThreadPoolExecutor 一个ThreadPoolExecutor的构造参数有 corePolSize -&gt;核心线程数 maximumPoolSize -&gt;线程池允许创建的最大线程数 keepAliveTime -&gt; 非核心线程闲置的超时时间，若超过这个时间便会回收 TimeUnit -&gt; keepAliveTime的时间单位 WorkQueue -&gt; 任务队列 ThreadFactory -&gt; 线程工厂 RejectedExecutionHandler -&gt; 饱和策略 WorkQueue： 任务队列，如果当前线程数大于corePoolSize，就会将任务添加到任务队列里面,这个也是阻塞队列（BlockingQueue） RejectedExecutionHandler：饱和策略，当任务队列和线程池都满了时采取的应对策略，默认是AboredPolicy,表示无法处理新的任务，会抛出异常，另外还有三种策略，CallerRunPolicy：用调用者所在的线程来处理任务；DiscardPolicy:不执行任务，直接删除任务；DiscardOldestPolicy:丢弃队列最近的任务，并执行当前的任务 线程池的处理流程 -&gt;提交任务 -&gt;检查线程是否到达核心线程数 -&gt;若没有达到，创建核心线程执行任务 -&gt;检查任务队列是否已满-&gt;若没有满，将任务添加到任务队列里面 -&gt;线程是否已经达到最大线程数-&gt;没有就创建执行任务 -&gt;执行饱和策略避免死锁 加锁顺序（线程按照一定顺序加锁） 加锁时限（线程尝试获取锁的时候加上一定时限，超过则放弃对锁的请求，并释放自己的锁） 死锁检测 4、各种锁1、自旋锁和互斥锁 自旋锁：是指没有获得锁会一直循环询问保持着是否已经释放锁，自旋的时间需要设定 自适应自旋：自旋的时间不再固定，由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。 互斥锁：没有获得锁的时候会将自己阻塞，等待别人释放锁后唤醒 自旋锁不会引起调用者的休眠，所以自旋锁的效率比互斥锁高，避免用户线程和内核切换的消耗。缺点是不能用在锁竞争激烈的情况 乐观锁和悲观锁 乐观锁 ：认为同一个数据的比你高发操作是不会发生修改的。在更新数据的时候，会采用尝试更新，不断更新的方式更新数据。乐观的认为，不加锁的并发操作是没有事的。 悲观锁：认为同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为是修改的。同一个数据的并发操作，悲观锁采取加锁的操作。 悲观锁适合写多的情景，乐观锁适合读操作多的场景。悲观锁在java中的使用，就是利用各种锁。乐观锁在java中的使用是无锁编程，常常采用CAS算法，典型的就是原子类，通过CAS自旋实现原子操作的更新 公平锁和非公平锁 公平锁：是指多个线程按照申请锁的顺序来获取锁。 非公平锁:指多个线程获取锁的顺序并不是按照申请锁的顺序 通过ReentrantLock，可以通过其构造函数来指定该锁是不是公平锁，默认它是非公平锁。非公平锁的有点在于吞吐量比公平锁要大。对于synchronized而言，也是一个非公平锁。 可重入锁 可重入锁：又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动取得锁。 例子：当一个锁的内部调用另一个加锁的方法时，不需要再获取锁。可以避免死锁 偏向锁、轻量级锁、重量级锁这三种指的是锁的状态，针对synchronized的 偏向锁：指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价 轻量级锁：指当锁是偏向锁的时候，呗另一个线程锁访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能 重量级锁：指当锁为轻量级的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低 5、面试sleep()和wait()区别1、两个方法来自不同的类，sleep来自Thread类，wait来自Object 2、sleep没有释放锁，wait释放锁使得其他线程可以使用同步控制块或者方法。sleep不让出系统资源，wait是进入线程等待池等待，出让系统资源。wait不加时间限制，需要notify/notifyAll唤醒，sleep可以设置时间自动醒来，时间不到则调用interrupt强行打断 3、sleep要捕获异常，wait、notifiy/notifyAll不需要 直接调用run()方法和调用start的区别直接调用run()：在线程内调用该runnable的run方法，可以重复多次调用，且无法开启一个线程start()方法：启动一个线程，调用该runnable对象的方法，不能多次启动一个线程 ThreadLocal实现原理首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。 初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。 然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。 主内存和工作内存代表什么主内存主要包括本地方法区和堆。每个线程都有一个工作内存，工作内存中主要包括两个部分，一个是属于该线程私有的栈和对主存部分变量拷贝的寄存器(包括程序计数器PC和cup工作的高速缓存区)。 AsynTask工作原理其内部维护了一个线程池，利用handler与主线程交互 有四个重要的方法 doPreExcute工作前执行 doInBackGround子线程中运行的耗时逻辑 onProgress主线程运行，参数代表进度 onPostExcute接收线程任务执行的结果，线程任务结束时自动调用 2和4的方法为必须复写]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM笔记]]></title>
    <url>%2F2019%2F02%2F21%2Fjvm%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1、Java内存区域和内存溢出异常1.1 运行时数据区域Java虚拟机在执行java程序时会把它管理的内存划分为若干个不同的数据区域。 1.1.1 程序计数器程序计数器可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码命令。 为了线程切换后能恢复到正确的执行位置，每条线都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 1.1.2 Java虚拟机栈java虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出口等信息。 每一个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机中入栈到出栈的过程。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（不同于对象，可能是一个指向对象起始地址的引用指针）和returnAddress类型（指向了一条字节码指令的地址）。 局部变量表在编译期完成局部变量表所需要的内存空间分配。在这个区域，jvm规定了两种异常 如果线程请求的深度大于虚拟机所允许的深度，将抛出StackOverflowError 如果虚拟机栈可以动态扩展，且扩展时无法申请到足够的内存，就抛出OutOfMemoryError 1.1.3 Java堆Java堆是Java虚拟机所管理的内存中最大的一块。Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。这块内存的唯一目的就是存放对象。所有对象实例和数组都需要在堆上分配。由于现在收集器基本都采用分代收集算法，所以java堆中还可以划分为：新生代和老年代。再细致一点可以分为Eden,From Survivor,To Survivor。 如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 1.1.4 方法区方法区也是各个线程共享的区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据。同样，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。 1.1.5 运行时常量池运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息以外，还有一项就是常量池，用于存放编译器生成的何种字面变量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。 1.2 HotSpot1.2.1 对象的创建创建对象，通常仅仅是一个new关键字而已。 创建的过程是：首先检查能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析、和初始化过。如果没有就先执行类加载过程。类加载检查通过以后，接下来虚拟机将为新生对象分配内存。对象所需要的内存大小在类加载完成后就可以完全确定，为对象划分空间的任务等同于把一块确定大小的内存从Java堆中划分出来。 方式有两种： “指针碰撞”,假设Java堆中内存是绝对规整的，所有用过的放一边，空闲的放另一边，中间有个指针作为分界，当移动中间指针时就可以划分出一个内存空间 “空闲列表”，若堆中的内存不规整，则需要用一个列表去维护记录哪些位置的空间可用，分配时只需要在列表中找到一块大的空间划分给对象就好。 采用哪种方法由垃圾收集器是否带有压缩整理功能决定。 为了保证创建对象的线程安全，jvm有两种方案： 对分配内存空间的动作进行同步处理 把内存分配的动作按照线程划分在不同的空间中进行，即让每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲-TLAB）。每次分配内存，在TLAB上进行分配，当缓冲区用完以后，才需要同步锁定。 分配完成以后，jvm将分配到的内存空间都初始化为零值，这样保证了对象的实例在java代码中可以不赋初值也可以使用。 接下来，虚拟机要对对象进行必要的设置，如这个对象是哪个类的实例、怎么找到类的元数据信息，对象的哈希码，对象的GC分代年龄等，这些都存在对象的对象头中。 对象分配内存的工作已经完成，接下来就执行构造方法里面的内容，按照程序员的意愿初始化对象。 2、垃圾收集器与内存的分配策略2.1 判断对象是否存活2.1.1 引用计数法 引用计数法：给对象中添加一个引用计数器，每次一个地方引用它，计数器就+1，当引用失效时，计数器减一。任何时候计数器不为0时的对象就是不可能被使用的。 主流的jvm里没有用这个方法来管理内存，因为最主要的原因是它很难解决对象之间相互循环引用的问题 2.1.2 可达性分析算法 可达性算法：通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径就是引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的 可以作为GC Roots的对象包括以下几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用的对象 2.1.3四种引用 强引用：指在代码中普遍存在的，类似Object object = new Object()，只要这类引用还在，垃圾收集器永远不会回收掉被引用的对象 软引用：用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果回收后还没有足够的内存，才抛出异常。可以用SoftReference类实现软引用。 弱引用：用来描述非必须对象，但是它的强度比软引用更弱一些，弱引用的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存是否足够，都会回收掉只被弱引用关联的对象。用WeakReference来实现弱引用。应用场景：软引用可以用来构建缓存队列，达到缓存且在JVM内存紧缺时不占用内存 虚引用：虚灵引用或者幻影引用，最弱的一种引用。虚引用无法用来取得对象实例。虚引用的存在是为了能在这个对象呗收集器回收时收到一个系统通知，以便在回收时能调用finalize() finalize()方法是对象逃脱死亡命运的最后一次机会，（只要与引用链上）对于任何一个对象的finalize方法只能杯系统自动调用一次，如果对象面临下一次回收，他的finalize方法不会再次执行。 2.1.4回收方法区方法区也称为永久代，永久代的来及收集主要回收两部分内容：废弃常量和无用的类。 判断一个类是否是一个无用的类，需要同时满足以下条件： 该类所有的实例已经被回收，也就是Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的.class对象没有在任何地方被引用，无法在任何地方通过翻身访问该类的方法 2.2垃圾收集算法2.2.1 标记-清除算法 该算法分为两个阶段：“标记”和“清除”。首先标记出所有的需要回收的对象，在标记完成后统一挥手所有被标记的对象。主要是利用可达性算法进行标记。 这个有两个不足之处： 效率问题：标记和清除的效率都不高 空间问题：标记清楚以后会产生大量不连续的碎片，空间碎片太多会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作 2.2.2复制算法如今的虚拟机都将此算法用在新生代上 将内存划分为一块较大的Eden空间和两块Survivor空间，每次使用一块Eden和一块Survivor(From Survivor)。当回收时，将Eden和一块Survivor的存活对象一次性复制到另一块Survivor(To Survivor)那里。如果To Survivor内存不足够存放，需要将此次需要复制的过来的对象存放到老年代里（分配担保）。（Eden : From Survivor : To Survivor ） 2.2.3 标记-整理算法该算法适合在老年代使用 该算法的过程与标记清除差不多，不同的是后续步骤不是对可收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 2.2.4 分代收集算法 仅仅根据对象存活周期的不同将内存划分为几块。一般是把Java堆划分为新生代和老年代。然后根据各个年代的特点采用最适合的收集算法。 2.2.5 算法实现枚举根节点可作为GC Roots的节点主要在全局性的引用与执行上下文中，如果要逐个检查这里面的引用，那么会带来消耗很多时间的现象。 由于可达性分析对执行时间的敏感体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行，不可以出现分析过程中对象引用关系还在不断变化的情况，所以导致GC进行时必须停顿所有JAVA执行线程。不管什么收集器，枚举根节点时都要停顿。 目前主流的Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，而在HotSpot的实现中，使用一组OopMap的数据结构来达到这个目的。 安全点程序执行并非在所有地方都能停下来开始GC，只有在到达安全点才能暂停。安全点的选取基本上以程序“是否具有让程序长时间执行的特征”为标准进行选定的。如在方法调用、循环跳转、异常跳转等（有种类似转折点的感觉） 安全区域 安全区域是指在一段代码片段之中，引用关系不会发生变法 2.4 内存分配与回收策略2.4.1 对象优先在Eden分配大多数情况下，对象在新生代Eden区中分配。当Eden没有足够的空间进行分配时，虚拟机将发起一次MinorGC 新生代GC(Minor GC)：指发生在新生代的垃圾收集动作 老年代GC (Major GC/Full GC)：指发生在老年代的GC，出现了Major GC ，经常会伴随至少一次的GC。Major GC的速度一般会比Major GC慢十倍以上。 2.4.2 大对象直接进入老年代大对象是指需要大量连续内存空间的Java对象，典型的大对象就是那种很长的字符串以及数组。通过设置JVM的一个参数，令大于这个设置值的对象直接在老年代分配，目的是避免在Eden区以及两个Survivor区之间发生大量的内存复制 2.4.3 长期存活的对象将进入老年代如果对象在Eden出生并经过一次Minor GC 后仍然存活，并能呗Survivor容纳的话，将移动到Survivor空间中，并且对象年龄设为1.对象在Survivor区中没度过一次Minor GC，年龄就增加1岁，当年龄增加到一定程度，就会被晋升到老年代中，晋升的临界值可以通过修改JVM参数设置。 2.4.4 动态对象年龄判定如果Survivor空间中年龄相同所有对象大小的总和大于Survivor空间一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等待临界值的到来 2.4.5 空间分配担保在Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的，如果不成立，则虚拟机会查看HandlePromotionFaliure（true/false）设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC ，尽管这次Minor GC是有风险的；如果小于，那这时也要改为进行一次Full GC。 3 虚拟机加载3.1 类加载的时机类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。这几个阶段并不是一个完成再到另一个，但它们开始的顺序是确定的。 只有5种情况必须对类进行“初始化”： 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行过初始化，就需要先对其初始化。而这4条指令的常见场景是：new关键字实例化对象、读取或设置一个类的静态字段，以及调用一个类的静态方法的时候 进行反射的时候 初始化一个类的时候，发现其父类没有进行过初始化，则需要先出发其父类的初始化 当虚拟机启动时，初始化主类（包含main()方法那个类） 当使用jdk 1.7动态语言支持时，如果一个java.lang,invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法所对应的类没有初始化，则需要先触发其实例化 3.2 类加载的过程3.2.1 加载加载是类加载过程的一个阶段，在这个阶段需要完成一下3件事： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 3.2.2 验证验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟自身的安全。 验证包括4个动作： 文件格式验证 元数据验证 字节码验证 符号引用验证 文件格式验证 是否以魔数0xCAFEBABE开头 主次版号是否在当前虚拟机处理范围之内 常量池的常量中是否有不被支持的常量类型 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量 CONSTANT_Utf8_info型常量中是否有不符合UTF-8编码的数据 Class文件中各个部分及文件本身是否有被删除的或附加的其他信息 这个阶段验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 元数据验证 这个类是否有父类 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法 类中的字段、方法、是否与父类产生矛盾 这个阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息 字节码验证这个阶段主要通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作 保证跳转指令不会跳到方法体以外的字节码指令上 保证方法体中的类型转换是有效的 符号引用验证这个阶段的校验发生在虚拟机将符号引用转化直接引用的时候 符号引用中通过字符串描述的全限定名是否能找到对应的类 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段 符号引用中的类、字段、方法的访问性（private,protected,public,default）是否可以被当前类访问 3.2.3 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存将在方法区中进行分配。这里分配的变量仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。 3.2.4 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可 直接引用：直接引用可以是指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。可以理解成一个地址 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 3.2.5 初始化初始化阶段是类加载过程的最后一步，在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源 &lt;clinit()&gt;方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义的静态语句块之前的变量 &lt;clinit()&gt;方法和类的构造函数不同，它不需要显式地调用父类构造器 接口中没有&lt;clinit()&gt;方法 3.3 类加载器3.3.1 双亲委派模型两种类加载器：启动类加载器（C++实现）、所有其他类加载器(java实现，继承自抽象类ClassLoader)三种类加载器：启动类加载器、扩展类加载器、应用程序加载器 双亲委派模型：要求除了顶层的启动类加载器以外，其余的类加载器都应当有自己的父类加载器。双亲委派的工作原理：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都因嘎嘎i传送给顶层的父类启动类加载器中，只有当父加载反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。由于使用这种模型，就会使Java类随着它的类加载器一起具备了一种带有优先级的层级关系，如类Object，保证了一个类的唯一性]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 架构组件]]></title>
    <url>%2F2019%2F02%2F21%2FAndroid%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. LifeCycleLifeCycle的组件主要用于生命周期的监听，一般可用于Activity和Fragment的生命周期监听。 LifeCycle的组件主要包括如下几个： LifecycleRegistryOwner LifecycleObserver 使用方法如下： 定义一个需要监听生命周期的组件，实现 LifecycleObserver 接口，使用 @OnLifecycleEvent 注解定义相关的生命周期 12345678910111213141516171819public class MyObserver implements LifecycleObserver&#123; private static final String TAG = &quot;MyObserver_TAG&quot;; @OnLifecycleEvent(Lifecycle.Event.ON_RESUME) public void onResume()&#123; Log.d(TAG,&quot;onResume&quot;); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_START) public void onStart()&#123; Log.d(TAG,&quot;onStart&quot;); &#125; @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE) public void onPause()&#123; Log.d(TAG,&quot;onPause&quot;); &#125;&#125; 给Activity或Fragment注册监听，实现 LifecycleRegistryOwner接口，实现 getLifecycle() 方法即可 1234567891011121314151617public class LifecycleActivity extends AppCompatActivity implements LifecycleRegistryOwner &#123; LifecycleRegistry lifecycleRegistry = new LifecycleRegistry(this); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_lifecycle); getLifecycle().addObserver(new MyObserver());//添加注册一个Observer &#125; @NonNull @Override public LifecycleRegistry getLifecycle() &#123; return lifecycleRegistry; &#125;&#125; LifeCycle的组件可以很大程度的帮助开发者实现生命周期监听而无需写更多的代码，在生命周期的管理中有大的作用 2. ViewModelViewModel是用来存储和管理UI相关的数据的，一遍数据在配置更改的时候还能生存进来 3. LiveDataLiveData是一个具有生命周期绑定的数据容器，用此容器封装的数据可以根据外界的生命周期变化而变化，LiveData]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
